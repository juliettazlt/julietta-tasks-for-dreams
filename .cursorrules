# Cursor AI Development Rules

## ğŸ¯ Core Development Philosophy
- **Simplicity first** - Always choose the simplest solution that works
- **Quality over speed** - Take time to write clean, maintainable code
- **Consistency** - Follow established patterns in the codebase

## ğŸ“¦ Technology Stack (LOCKED)
**NEVER add new packages. Use ONLY these existing tools:**

### Frontend
- React 18 + TypeScript
- Vite (build tool)
- Tailwind CSS (styling)
- shadcn/ui (UI components)
- Radix UI (headless primitives)
- Lucide React (icons)

### Backend & Data
- Supabase (database + auth)
- React Query (data fetching)

### Utilities
- date-fns (date operations)
- React Hook Form + Zod (forms + validation)
- Sonner (notifications)
- React Router DOM (routing)

## ğŸš« STRICT PROHIBITIONS

### Package Management
- âŒ NEVER suggest installing new packages
- âŒ NEVER use npm install, yarn add, or any package managers
- âŒ If existing tools can't solve something, explain limitations instead of adding packages
- âœ… Be creative within existing constraints

### Code Duplication
- âŒ NEVER duplicate existing code when adding new features
- âŒ NEVER rewrite existing functions unless explicitly requested
- âœ… Always check for existing utilities in `/src/lib/utils.ts`
- âœ… Reuse existing components from `/src/components/`
- âœ… Extract common logic into reusable functions

### File Management
- âŒ NEVER overwrite `.env` files
- âŒ NEVER create scripts that will only run once
- âŒ NEVER write inline scripts in components if avoidable
- âœ… Put reusable logic in appropriate utility files

### File Size Limits
- âŒ NEVER create files over 200-300 lines
- âœ… Split large files into smaller, focused modules
- âœ… Extract components when files get too large
- âœ… Use composition over large monolithic components

## âœ… DEVELOPMENT BEST PRACTICES

### Code Changes
- **Surgical precision** - Only make changes that are explicitly requested
- **Related changes only** - If adding feature X, only modify code related to X
- **Confidence requirement** - Only make changes you fully understand
- **Ask before major refactors** - Get permission before restructuring

### Environment Separation
- **Development** - Use development data and settings
- **Test** - Use test data and mocked services ONLY for testing
- **Production** - Use real data and production settings
- âŒ NEVER mix environments or use production data in development

### Data Handling
- âœ… **Mock data for tests ONLY** - Use in test files and test environments
- âŒ **NEVER use mock data in development or production**
- âœ… Use Supabase for all real data needs
- âœ… Use TypeScript interfaces for data structure

### Component Architecture
```typescript
// âœ… GOOD: Small, focused components
const TaskCard = ({ task }: { task: Task }) => {
  return <Card>...</Card>
}

// âŒ BAD: Giant components doing everything
const MegaTaskDashboardWithEverything = () => {
  // 300+ lines of code
}
```

### File Organization
```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/              # shadcn/ui components only
â”‚   â”œâ”€â”€ TaskCard.tsx     # âœ… Small, focused (< 100 lines)
â”‚   â””â”€â”€ TaskList.tsx     # âœ… Single responsibility
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ Dashboard.tsx    # âœ… Page-level component
â”‚   â””â”€â”€ Settings.tsx     # âœ… Another page
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ utils.ts         # âœ… Shared utilities
â”‚   â””â”€â”€ api.ts           # âœ… API functions
â””â”€â”€ hooks/
    â”œâ”€â”€ useTask.ts       # âœ… Custom hooks
    â””â”€â”€ useAuth.ts       # âœ… Reusable logic
```

## ğŸ¨ UI/Design Guidelines

### Styling Rules
- âœ… **Tailwind CSS ONLY** - No custom CSS files
- âœ… **shadcn/ui components** - Use as building blocks
- âœ… **Customize through props** - Extend components via className
- âŒ NO inline styles or styled-components

### Design Consistency
- âœ… Use Tailwind's design tokens (spacing, colors, typography)
- âœ… Follow shadcn/ui design patterns
- âœ… Maintain consistent spacing and typography scales
- âŒ NO random pixel values or custom breakpoints

### Component Reusability
```tsx
// âœ… GOOD: Flexible, reusable component
const StatusBadge = ({ status, className }: StatusBadgeProps) => (
  <Badge className={cn("capitalize", className)} variant={getVariant(status)}>
    {status}
  </Badge>
)

// âŒ BAD: Hardcoded, single-use component
const CompletedTaskBadge = () => (
  <div style={{ backgroundColor: 'green', padding: '4px' }}>
    Completed
  </div>
)
```

## ğŸ” Problem-Solving Approach

### When Implementing New Features:
1. **Survey existing code** - What similar patterns exist?
2. **Reuse existing components** - Can shadcn/ui components be composed?
3. **Extend, don't rebuild** - Modify existing utilities instead of creating new ones
4. **Test with existing tools** - Use React Testing Library + Vitest

### When Debugging:
1. **Check existing code first** - Is there already a solution?
2. **Use browser dev tools** - Debug with built-in tools
3. **Console.log strategically** - Don't install debug packages
4. **Fix root cause** - Don't add packages to work around issues

### When Optimizing:
1. **Use React dev tools** - Analyze performance with existing tools
2. **Optimize existing code** - Improve what's there before adding new tools
3. **Leverage React Query** - Use existing caching and data management

## ğŸš¨ Emergency Exceptions

**Only break these rules if:**
- Security vulnerability requires immediate package update
- Supabase changes require client library update
- Core React/Vite ecosystem updates are needed

**Process for exceptions:**
1. Document the critical need
2. Choose minimal, focused package
3. Set removal date if temporary
4. Update this rules file

## ğŸ’¬ Communication with AI Assistants

**Always remind AI assistants:**
```
"Follow the package policy in .cursorrules - use ONLY existing packages. 
No new installations. Be creative within current constraints."
```

**Example responses you want:**
- âœ… "Let's build this using shadcn/ui Dialog + Tailwind animations"
- âŒ "Let's install react-modal for this feature"

## ğŸ¯ Success Metrics

**This approach succeeds when:**
- Package.json stays stable over time
- Bundle size remains small
- Code patterns are consistent
- New developers can understand the codebase quickly
- Features are built faster (no research on new packages)

---

*Remember: Constraints breed creativity. Having fewer tools forces you to master the ones you have.*